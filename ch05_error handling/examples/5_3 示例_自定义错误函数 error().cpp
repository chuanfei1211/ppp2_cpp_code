//=====================================================
// 第5章 错误处理 —— 示例 5_4：自定义错误处理函数 error()
// 目标：将 throw runtime_error 封装成 error()，让错误处理更简洁。
//=====================================================

#include <iostream>
#include <stdexcept>    // runtime_error
#include <string>       // string
using namespace std;


/*
=====================================================
【为什么要自定义 error()？】
=====================================================

在写程序时，我们经常写：

    if (x < 0) {
        throw runtime_error("x 不能为负数");
    }

缺点：
    1）重复写 throw runtime_error(...) 比较烦
    2）代码风格不统一
    3）将来想修改错误处理方式（比如加日志），要改很多地方

解决：
    封装一个 error() 函数，把错误处理统一起来。

以后只需写：
    error("x 不能为负数");

这就是本节的核心思想。
*/


//=====================================================
// 函数：error —— 封装 runtime_error，统一抛出异常
//=====================================================
void error(const string& msg)
{
    // 关键语句：
    // throw 会立即终止当前函数，并把错误交给外层 catch。
    throw runtime_error(msg);
}

// 重载版本：支持拼接两个字符串，例如 error("a=", "3")
void error(const string& s1, const string& s2)
{
    error(s1 + s2);     // 调用上面的 error()
}



/*
=====================================================
【示例：安全除法 safe_divide(a, b)】
=====================================================

需求：
    读入 a、b，计算 a / b
    如果 b == 0 → 这是逻辑错误，必须报错

传统写法：
    if (b == 0) throw runtime_error("除数不能为 0");

现在写法：
    if (b == 0) error("除数不能为 0");

更加清晰、直观、易维护。
*/


//=====================================================
// 函数：safe_divide —— 如果 b==0，调用 error() 抛错误
//=====================================================
double safe_divide(double a, double b)
{
    if (b == 0)
    {
        // 比写 throw runtime_error("除数不能为0") 更简洁
        error("除数不能为 0！");
    }

    return a / b;   // 正常返回计算结果
}



/*
=====================================================
【主函数：测试 error() 的使用方式】
=====================================================
*/
int main()
{
    try
    {
        double a = 0;
        double b = 0;

        cout << "请输入两个数（a b）：";
        cin >> a >> b;     // 不做输入验证，重点是展示 error()

        // 可能抛出异常
        double result = safe_divide(a, b);

        cout << "a / b = " << result << endl;
    }
    catch (runtime_error& e)
    {
        // 捕获 error() 抛出的错误
        cerr << "发生错误："
            << e.what()   // 输出错误说明文字
            << endl;
    }

    return 0;
}



/*
=====================================================
【总结：error() 的意义】
=====================================================

✔ 1. error() 统一错误处理逻辑
    - 今后程序里只写：
         error("错误说明");
    - 不再重复写 throw runtime_error(...)

✔ 2. error() 让代码更整洁
    - 错误检查变成一句简单的调用

✔ 3. error() 让错误处理更易维护
    - 如果想记录日志，只需修改 error() 一个地方
    - 所有抛出的错误行为都会同步更新

✔ 4. error() 的风格与《基础篇》教材一致
    - 读书、写代码不再脱节

=====================================================
*/
